# The dice display value is set to r0, so that's our output register.
# r17 doesn't seem to be in use, so we'll hijack that.
# We will use register r18 from the call-site too.

# load the current player number into r18
lis r17, 0x805D
lbz r18, 0x3B80(r17) # current player number is at 0x805D3B80

# the player number will act as an offset from p1's info structure address. Structures are offset by 0x110 bytes.
# r18 will now store the full offset.
mulli r18, r18, 0x110

# load the cpu difficulty/is-player value into memory
lis r17, 0x8029
ori r17, r17, 0x0C98 # 0x80290C98 is where the first difficulty/is-player value is stored
add r17, r17, r18 # add the offset to the base memory value
lbz r17, 0(r17)

# if it is a computer player, then skip to the end
andi. r0, r17, 0x20 # this bit will be set for CPUs but not human players
bne default

# if the flag for 10 dice block is set, then skip to the end
lis r17, 0x8172
ori r17, r17, 0x0000
lbz r17, 0(r17)
andi. r0, r17, 0x01
bne default

# set the die value to 1
li r0, 0
b end

# overwritten code from the callsite that will handle the default case
default:
rlwinm r0, r3, 1, 0, 30
addi r3, r1, 44
lhax r0, r3, r0

end:
# set the value in memory (this is copied from the callsite)
sth r0, 0x0054(r29)

# go back to the callsite
lis r18, 0x8018
ori r18, r18, 0xCC94
mtctr r18
bctr
